<!DOCTYPE html>
<html lang="ja">

<head>
	<link rel="stylesheet" href="jscss/main.css">
	<link rel="stylesheet" href="jscss/checkbox_tree.css">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<script src="./jscss/exampleText.js"></script>
	<script src="./jscss/kuromoji.js"></script>
	<script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
	<script type="text/javascript" src="./jscss/sparql.js" charset="UTF-8"></script>
	<script src="./jscss/dbpedia_category.js"></script>
	<script src="./jscss/categorylist_color.js"></script>
	<!-- new modules -->
	<script src="./modules/morphologicalAnalysis.js"></script>
	<script src="./modules/search.js"></script>
	<script src="./modules/sparql.js"></script>
	<script src="./modules/loading.js"></script>
	<title>Wikidataのクラス階層を用いたエンティティリンキング</title>
	<!-- 複合語の検索用関数 -->
	<script>
		//完全一致検索
		async function exactMatchSearch(fukugougoArray, search_word_str, searchWordArray, search_word_pos, APIlimit) {
			let fukugou_APIres = new Array();
			if (2 < fukugougoArray.length) {
				//三単語以上の複合語をAPIで検索

				//単語の問い合わせ結果を格納-----1
				let res0 = await promise_get_action_wbsearchentities(search_word_str, APIlimit);
				let tmpres = new Array();
				for (let j = 0; j < res0.search.length; j++) {
					if (res0.search[j].match.text == search_word_str) {
						tmpres.push(res0.search[j]);
					}
				}
				let res0search = label_type(tmpres);
				//console.log(res0.searchinfo.search, res0);
				if (res0search.length != 0) {
					fukugou_APIres.push({
						'name': res0.searchinfo.search,
						'word_position': fukugougoArray[0].word_position,
						'word_count': fukugougoArray.length,
						'search': res0search,
						"pos": search_word_pos
					});
				} else if (res0search.length == 0) {	//検索結果が見つからなかった場合分割して検索

					//まずは後ろを塊にして検索
					let res1 = await full_three_words_or_more_behind(searchWordArray, APIlimit, search_word_pos);
					if (res1 == 0) {

						//今度は前を塊にして検索
						let res2 = await full_three_words_or_more_forward(searchWordArray, APIlimit, search_word_pos);
						if (res2 == 0) {
							//0が返ってきた場合複合語での検索結果は見つかっていない
							console.log(search_word_str, "は検索結果無");
						} else if (res2 != 0) {

							if (res2.search.length != 0) {
								fukugou_APIres.push({
									'name': res2.searchinfo.search,
									'word_position': fukugougoArray[0].word_position,
									'word_count': res2.word_count,
									'search': res2.search,
									'pos': res2.pos
								});
							}
						}

					} else if (res1 != 0) {
						if (res1.search.length != 0) {
							let word_position;
							for (let j = 0; j < fukugougoArray.length; j++) {
								if (res1.searchinfo.search.indexOf(fukugougoArray[j].name) == 0) {
									word_position = fukugougoArray[j].word_position;
								}
							}

							fukugou_APIres.push({
								'name': res1.searchinfo.search,
								'word_position': word_position,
								'word_count': res1.word_count,
								'search': res1.search,
								'pos': res1.pos
							});
						}
					}
				}
			} else {
				//二単語の複合語の検索

				//単語の問い合わせ結果を格納-----2
				let res = await promise_get_action_wbsearchentities(search_word_str, APIlimit);
				let tmpres = new Array();
				for (let j = 0; j < res.search.length; j++) {
					if (res.search[j].match.text == search_word_str) {
						tmpres.push(res.search[j]);
					}
				}
				//console.log(tmpres);
				let ressearch = label_type(tmpres);
				if (ressearch.length != 0) {
					fukugou_APIres.push({
						'name': res.searchinfo.search,
						'word_position': fukugougoArray[0].word_position,
						'word_count': fukugougoArray.length,
						'search': ressearch,
						'pos': search_word_pos
					});
				} else {
					console.log(search_word_str, 'は検索結果無')
				}
			}
			return fukugou_APIres;
		}
		//前方一致検索
		async function prefixSearch(fukugougoArray, search_word_str, searchWordArray, search_word_pos, APIlimit) {
			let fukugou_APIres = new Array();
			if (2 < fukugougoArray.length) {
				//三単語以上の複合語をAPIで検索

				let res0 = await promise_get_action_wbsearchentities(search_word_str, APIlimit);
				res0.word_count = searchWordArray.length;
				//console.log(res0.searchinfo.search, res0);

				let res0search = label_type(res0.search);
				if (res0search.length != 0) {
					fukugou_APIres.push({
						'name': res0.searchinfo.search,
						'word_position': fukugougoArray[0].word_position,
						'word_count': fukugougoArray.length,
						'search': res0search,
						'pos': search_word_pos
					});

				} else if (res0.search.length == 0) { //検索結果が見つからなかった場合分割して検索

					//まずは後ろを塊にして検索
					let res1 = await forward_three_words_or_more_behind(searchWordArray, APIlimit, search_word_pos);
					if (res1 == 0) {

						//今度は前を塊にして検索
						let res2 = await forward_three_words_or_more_forward(searchWordArray, APIlimit, search_word_pos);
						if (res2 == 0) {
							//0が返ってきた場合複合語での検索結果は見つかっていない
							console.log(search_word_str, "は検索結果無");
						} else if (res2 != 0) {
							if (res2.search.length != 0) {
								fukugou_APIres.push({
									'name': res2.searchinfo.search,
									'word_position': fukugougoArray[0].word_position,
									'word_count': res2.word_count,
									'search': res2.search,
									'pos': res2.pos
								});
							}
						}

					} else if (res1 != 0) {
						if (res1.search.length != 0) {
							let word_position;
							for (let j = 0; j < fukugougoArray.length; j++) {
								if (res1.searchinfo.search.indexOf(fukugougoArray[j].name) == 0) {
									word_position = fukugougoArray[j].word_position;
								}
							}

							fukugou_APIres.push({
								'name': res1.searchinfo.search,
								'word_position': word_position,
								'word_count': res1.word_count,
								'search': res1.search,
								'pos': res1.pos
							});
						}
					}
				}

			} else {
				//二単語の複合語の検索

				let res = await promise_get_action_wbsearchentities(search_word_str, APIlimit);
				let ressearch = label_type(res.search);
				if (ressearch.length != 0) {
					fukugou_APIres.push({
						'name': res.searchinfo.search,
						'word_position': fukugougoArray[0].word_position,
						'word_count': fukugougoArray.length,
						'search': ressearch,
						'pos': search_word_pos
					});
				} else {
					console.log(search_word_str, 'は検索結果無')
				}
			}
			return fukugou_APIres;
		}

		async function ambiguousSearch(fukugougoArray, search_word_str, searchWordArray, search_word_pos, APIlimit) {
			let fukugou_APIres = new Array();
			if (2 < fukugougoArray.length) {
				//三単語以上の複合語をAPIで検索

				let res0 = await promise_get_list_search(search_word_str, APIlimit);
				res0.word_count = searchWordArray.length;
				console.log(search_word_str, res0);

				if (res0.query.search.length != 0) {
					fukugou_APIres.push({
						'name': search_word_str,
						'word_position': fukugougoArray[0].word_position,
						'word_count': fukugougoArray.length,
						'search': res0.query.search,
						'pos': search_word_pos
					});

				} else if (res0.query.search.length == 0) { //検索結果が見つからなかった場合分割して検索

					//まずは後ろを塊にして検索
					let res1 = await ambi_three_words_or_more_behind(searchWordArray, APIlimit, search_word_pos);
					if (res1 == 0) {

						//今度は前を塊にして検索
						let res2 = await ambi_three_words_or_more_forward(searchWordArray, APIlimit, search_word_pos);
						if (res2 == 0) {
							//0が返ってきた場合複合語での検索結果は見つかっていない
							console.log(search_word_str, "は検索結果無");
						} else if (res2 != 0) {
							if (res2.query.search.length != 0) {
								fukugou_APIres.push({
									'name': search_word_str,
									'word_position': fukugougoArray[0].word_position,
									'word_count': res2.word_count,
									'search': res2.query.search,
									"pos": res2.pos
								});
							}
						}

					} else if (res1 != 0) {
						if (res1.query.search.length != 0) {
							const num = searchWordArray.length - res1.word_count;
							const word_position = fukugougoArray[num].word_position;

							fukugou_APIres.push({
								'name': search_word_str,
								'word_position': word_position,
								'word_count': res1.word_count,
								'search': res1.query.search,
								'pos': res1.pos
							});
						}
					}
				}

			} else {
				//二単語の複合語の検索

				let res = await promise_get_list_search(search_word_str, APIlimit);
				//console.log(res);
				if (res.query.search.length != 0) {
					fukugou_APIres.push({
						'name': search_word_str,
						'word_position': fukugougoArray[0].word_position,
						'word_count': fukugougoArray.length,
						'search': res.query.search,
						'pos': search_word_pos
					});
				} else {
					console.log(search_word_str, 'は検索結果無')
				}
			}
			return fukugou_APIres;
		}
	</script>
	<!-- 複合語関連の関数 -->
	<script>
		//複合語の取り出し
		function associated_noun(words) {
			let position;
			let associated_nouns = new Array();
			let j = 0;

			for (let i = 0; i < words.length; i++) {
				let tmparray = new Array();
				let pos1 = {
					"name": words[i].surface_form,
					"pos_detail_1": words[i].pos_detail_1,
					"pos_detail_2": words[i].pos_detail_2,
					"pos_detail_3": words[i].pos_detail_3
				};
				let dct = {
					"name": words[i].surface_form,
					"word_position": words[i].word_position,
					"pos": pos1
				};
				tmparray.push(dct);

				position = words[i].word_position + words[i].surface_form.length;
				//console.log("一番目の単語位置", words[i].word_position, "次の単語位置(予測)", position);

				j = i + 1;
				//console.log(i, j);

				let k = 0;
				while ((j < words.length) && (position == words[j].word_position)) {
					//console.log("次の単語位置", words[j].word_position);
					let pos2 = {
						"name": words[j].surface_form,
						"pos_detail_1": words[j].pos_detail_1,
						"pos_detail_2": words[j].pos_detail_2,
						"pos_detail_3": words[j].pos_detail_3
					};
					let dct = {
						"name": words[j].surface_form,
						"word_position": words[j].word_position,
						"pos": pos2
					};
					tmparray.push(dct);
					position += words[j].surface_form.length;
					k++;
					j++;
				}
				i += k;
				if (1 < tmparray.length) {
					associated_nouns.push(tmparray);
					//console.log(tmparray);
				}

			}
			//console.log("複合語(名詞と名詞)", associated_nouns);
			return associated_nouns;
		}

		//(完全一致)三つ以上の複合語の後方検索処理(複合語リスト,APIlimit,品詞)
		async function full_three_words_or_more_behind(wordsArray, searchLimit, partOfSpeech) {
			let len = wordsArray.length;
			if (len - 1 > 1) {
				let tmpWordsArray = new Array();
				let tmpPartOfSpeech = new Array();
				for (let i = 1; i < len; i++) {
					tmpWordsArray.push(wordsArray[i]);
					tmpPartOfSpeech.push(partOfSpeech[i]);
				}
				let compoundWord = tmpWordsArray.join('');
				let res1 = await promise_get_action_wbsearchentities(compoundWord, searchLimit);
				res1.word_count = tmpWordsArray.length;
				let tmpres = new Array();
				for (let i = 0; i < res1.search.length; i++) {
					if (res1.search[i].match.text == compoundWord) {
						tmpres.push(res1.search[i]);
					}
				}
				let res1search = label_type(tmpres);
				res1.pos = tmpPartOfSpeech;

				//console.log(compoundWord, res1)
				if (res1search.length == 0) {
					let res2 = await full_three_words_or_more_behind(tmpWordsArray, searchLimit, partOfSpeech);
					if (res2 != 0) {
						return res2;
					} else {
						return 0;
					}
				} else if (res1search.length != 0) {
					res1.search = res1search;
					return res1
				}

			} else {
				return 0;
			}
		}
		//(完全一致)三つ以上の複合語の前方検索処理(複合語リスト,APIlimit,品詞)
		async function full_three_words_or_more_forward(wordsArray, searchLimit, partOfSpeech) {
			let len = wordsArray.length;
			if (len - 1 > 1) {
				let tmpWordsArray = new Array();
				let tmpPartOfSpeech = new Array();
				for (let i = 0; i < len - 1; i++) {
					tmpWordsArray.push(wordsArray[i]);
					tmpPartOfSpeech.push(partOfSpeech[i]);
				}
				let compoundWord = tmpWordsArray.join('');
				let res1 = await promise_get_action_wbsearchentities(compoundWord, searchLimit);
				//console.log(res1);
				res1.word_count = tmpWordsArray.length;
				let tmpres = new Array();
				for (let i = 0; i < res1.search.length; i++) {
					if (res1.search[i].match.text == compoundWord) {
						tmpres.push(res1.search[i]);
					}
				}
				//console.log('完全一致', tmpres)

				let res1search = label_type(tmpres);
				res1.pos = tmpPartOfSpeech;
				//console.log(res1.pos);

				//console.log(compoundWord, res1);
				if (res1search.length == 0) {
					let res2 = await full_three_words_or_more_forward(tmpWordsArray, searchLimit, partOfSpeech);
					if (res2 != 0) {
						return res2;
					} else {
						return 0;
					}
				} else if (res1search.length != 0) {
					res1.search = res1search;
					return res1;
				}

			} else {
				return 0;
			}
		}

		//(前方一致)三つ以上の複合語の後方検索処理(複合語リスト,APIlimit,品詞)
		async function forward_three_words_or_more_behind(words, limit, pos) {
			let len = words.length;
			if (len - 1 > 1) {
				let tmpwords = new Array();
				let tmppos = new Array();
				for (let i = 1; i < len; i++) {
					tmpwords.push(words[i]);
					tmppos.push(pos[i]);
				}
				let words_str = tmpwords.join('');
				let res1 = await promise_get_action_wbsearchentities(words_str, limit);
				let res1search = label_type(res1.search);

				res1.word_count = tmpwords.length;
				res1.pos = tmppos;
				//console.log(words_str, res1)

				if (res1search.length == 0) {
					let res2 = await forward_three_words_or_more_behind(tmpwords, limit, pos);
					if (res2 != 0) {
						return res2;
					} else {
						return 0;
					}
				} else if (res1search.length != 0) {
					res1.search = res1search;
					return res1;
				}

			} else {
				return 0;
			}
		}
		//(前方一致)三つ以上の複合語の前方検索処理(複合語リスト,APIlimit,品詞)
		async function forward_three_words_or_more_forward(words, limit, pos) {
			let len = words.length;
			//console.log(pos);
			if (len - 1 > 1) {
				let tmpwords = new Array();
				let tmppos = new Array();
				for (let i = 0; i < len - 1; i++) {
					tmpwords.push(words[i]);
					tmppos.push(pos[i]);
				}
				let words_str = tmpwords.join('');
				let res1 = await promise_get_action_wbsearchentities(words_str, limit);
				let res1search = label_type(res1.search);

				res1.word_count = tmpwords.length;
				res1.pos = tmppos;
				//console.log(words_str, res1)
				if (res1.search.length == 0) {
					let res2 = await forward_three_words_or_more_forward(tmpwords, limit, pos);
					if (res2 != 0) {
						return res2;
					} else {
						return 0;
					}
				} else if (res1.search.length != 0) {
					res1.search = res1search;
					return res1;
				}

			} else {
				return 0;
			}
		}

		//(あいまい)三つ以上の複合語の後方検索処理(複合語リスト,APIlimit,品詞)
		async function ambi_three_words_or_more_behind(wordsArray, searchLimit, partOfSpeech) {
			let len = wordsArray.length;
			if (len - 1 > 1) {
				let tmpWordsArray = new Array();
				let tmpPartOfSpeech = new Array();
				for (let i = 1; i < len; i++) {
					tmpWordsArray.push(wordsArray[i]);
					tmpPartOfSpeech.push(partOfSpeech[i]);
				}
				let compoundWord = tmpWordsArray.join('');
				let res1 = await promise_get_list_search(compoundWord, searchLimit);
				res1.word_count = tmpWordsArray.length;
				res1.pos = tmpPartOfSpeech;
				console.log(compoundWord, res1)
				if (res1.query.search.length == 0) {
					let res2 = await ambi_three_words_or_more_behind(tmpWordsArray, searchLimit, partOfSpeech);
					if (res2 != 0) {
						return res2;
					} else {
						return 0;
					}
				} else if (res1.query.search.length != 0) {
					return res1;
				}

			} else {
				return 0;
			}
		}
		//(あいまい)三つ以上の複合語の前方検索処理(複合語リスト,APIlimit,品詞)
		async function ambi_three_words_or_more_forward(wordsArray, searchLimit, partOfSpeech) {
			let len = wordsArray.length;
			if (len - 1 > 1) {
				let tmpWordsArray = new Array();
				let tmpPartOfSpeech = new Array();
				for (let i = 0; i < len - 1; i++) {
					tmpWordsArray.push(wordsArray[i]);
					tmpPartOfSpeech.push(partOfSpeech[i]);
				}
				let compoundWord = tmpWordsArray.join('');
				let res1 = await promise_get_list_search(compoundWord, searchLimit);
				res1.word_count = tmpWordsArray.length;
				res1.pos = tmpPartOfSpeech;
				console.log(compoundWord, res1)
				if (res1.query.search.length == 0) {
					let res2 = await ambi_three_words_or_more_forward(tmpWordsArray, searchLimit, partOfSpeech);
					if (res2 != 0) {
						return res2;
					} else {
						return 0;
					}
				} else if (res1.query.search.length != 0) {
					return res1;
				}

			} else {
				return 0;
			}
		}
	</script>
	<!-- main以外の関数 -->
	<script>

		//人物名の抽出
		function person_name(tokens) {
			let person_name_array = new Array();
			let tmp_pname;
			let word_position;
			for (let i = 0; i < tokens.length - 2; i++) {
				if ((tokens[i].pos == '名詞') && (tokens[i + 1].surface_form == '・') && (tokens[i + 2].pos == '名詞')) {
					if (word_position == tokens[i].word_position) {
						tmp_pname.push(tokens[i + 1], tokens[i + 2]);
						person_name_array.pop();
						person_name_array.push(tmp_pname);
						word_position = tokens[i + 2].word_position;
						i += 1;
					} else {
						tmp_pname = [tokens[i], tokens[i + 1], tokens[i + 2]];
						word_position = tokens[i + 2].word_position;
						person_name_array.push(tmp_pname);
						i += 1;
					}
				} else if ((tokens[i].pos == '名詞') && (tokens[i + 1].surface_form == ' ') && (tokens[i + 2].pos == '名詞')) {
					tokens[i + 1].surface_form = '';
					tmp_pname = [tokens[i], tokens[i + 1], tokens[i + 2]];
					person_name_array.push(tmp_pname);
				}
			}
			return person_name_array;
		}

	</script>
	<!-- main関数 -->
	<script>
		async function main() {
			//ログだからvarにしてあるけど、なぜか関数に引数として渡してる
			//ウィキデータ系の総合ログ
			var wikidata_log = new Array();
			//SPARQLQUERYの総合ログ
			var SPARQL_log = new Array();

			//API検索結果のカテゴリ一覧
			var searched_category = new Array();

			//カテゴリーチェックボックス結果
			let checklist = new Map();
			let matchlist = new Map();

			//最終結果を格納する変数
			let textOUTPUT = '';

			//カテゴリーチェックボックス階層
			const CATcheckbox = document.getElementsByClassName('hierarchy0');
			for (let i = 0; i < CATcheckbox.length; i++) {
				//console.log(CATcheckbox[i]);
				if (CATcheckbox[i].checked) {
					checklist.set(CATcheckbox[i].id, CATcheckbox[i].value);

					let j = 0;
					while (true) {
						//チェックボックスのidを取得(2階層目まではこれで対応)
						let CATcheckbox1 = document.getElementById('cat-' + i + '-' + j);
						if (CATcheckbox1 != null) {
							if (CATcheckbox1.checked) {
								checklist.delete(CATcheckbox[i].id);
								checklist.set(CATcheckbox1.id, CATcheckbox1.value);
							}
							j++;
						} else {
							break;
						}
					}
				}
			}
			console.log('カテゴリナンバー → カテゴリ名', checklist);

			for (let dbpedia_category of dbpedia_categorylist) {
				for (let val of checklist.values()) {
					if (dbpedia_category.clsLabel.value == val) {
						matchlist.set(val, dbpedia_category.o.value);
					}
				}
			}
			console.log('カテゴリ名 → wikidata_url', matchlist);

			//--------------------------------設定情報を取得--------------------------------
			//サーチAPIの結果取得上限数
			const APIlimit = document.getElementById('APIlimit').value;
			//詳細設定ラジオボタン
			const select_noun = radio_value('radio_noun');
			const searchtype = radio_value('labelType');
			const linktype = radio_value('linkType');

			//--------------------------------入力テキスト取得--------------------------------
			const textINPUT = document.getElementById('input_text').value;

			//--------------------------------形態素解析--------------------------------
			//kuoromoji形態素解析結果の格納
			var tokens = await promise_analysis(textINPUT);

			//--------------------------------START 形態素解析結果から、必要なものを抽出--------------------------------
			var words = new Array(); //フィルタリング後の形態素解析結果
			//----------------人物名----------------
			const tmp_person_name_array = person_name(tokens);
			//console.log('人物名', tmp_person_name_array);
			//複合語の配列と同じ形式に変換
			let person_name_array = new Array();
			for (let i = 0; i < tmp_person_name_array.length; i++) {
				let tmp_array = new Array();
				for (const element of tmp_person_name_array[i]) {
					tmp_array.push({
						name: element.surface_form,
						word_position: element.word_position,
						pos: {
							name: element.surface_form,
							pos_detail_1: element.pos_detail_1,
							pos_detail_2: element.pos_detail_2,
							pos_detail_3: element.pos_detail_3
						}
					})
				}
				person_name_array.push(tmp_array);
			}
			console.log('人物名', person_name_array);
			//----------------名詞----------------
			tokens.forEach((token) => {
				// 解析結果を順番に取得する
				if (select_noun == "u_noun") {
					if (token.pos_detail_1 == "固有名詞") {
						//固有名詞を抽出
						words.push(token);
					}
				} else {
					if (token.pos == "名詞") {
						//名詞を抽出
						words.push(token);
					}
				}
			});
			//単語の出現順にソート
			words.sort(function (a, b) {
				return a.word_position - b.word_position;
			});
			//----------------ブラックリスト ホワイトリスト----------------
			//ブラックリストかホワイトリストを使用するか判定
			if (select_noun == 'noun_w' || select_noun == 'noun_b') {
				const nounvalue = document.getElementById(select_noun).value;
				const nounlist = nounvalue.split(',');

				if (select_noun == 'noun_w') {
					words = match_whitelist(nounlist, words);
				} else if (select_noun == 'noun_b') {
					words = match_blacklist(nounlist, words);
				}
			}
			words = NGword(words);
			//単語の出現順にソート
			words.sort(function (a, b) {
				return a.word_position - b.word_position;
			});

			console.log("wikidata検索ワード", words);
			//--------------------------------END 形態素解析結果から、必要なものを抽出--------------------------------
			//--------------------------------START 複合語検索--------------------------------
			//複合語の取り出して検索
			let fukugougo = associated_noun(words);
			//複合語配列と人物名配列の結合
			fukugougo = fukugougo.concat(person_name_array);
			console.log("複合語", fukugougo);
			let fukugou_linked_string = new Array();
			if (fukugougo.length != 0) {
				let fukugou_APIres = [];

				for (let i = 0; i < fukugougo.length; i++) {
					let searchWordArray = fukugougo[i].map(obj => obj.name);
					let search_word_str = searchWordArray.join('');
					let search_word_pos = fukugougo[i].map(obj => obj.pos);

					if (searchtype == "Full") {
						fukugou_APIres = [...fukugou_APIres, ...(await exactMatchSearch(fukugougo[i], search_word_str, searchWordArray, search_word_pos, APIlimit))];
					} else if (searchtype == "forward") {
						fukugou_APIres = [...fukugou_APIres, ...(await prefixSearch(fukugougo[i], search_word_str, searchWordArray, search_word_pos, APIlimit))];
					} else if (searchtype == "ambi") {
						fukugou_APIres = [...fukugou_APIres, ...(await ambiguousSearch(fukugougo[i], search_word_str, searchWordArray, search_word_pos, APIlimit))];
					}
				}
				console.log("複合語検索結果", fukugou_APIres);

				if (searchtype == 'ambi') {
					for (let i = 0; i < fukugou_APIres.length; i++) {
						let wikidata_ids = '';
						let name = fukugou_APIres[i].name;
						let info = fukugou_APIres[i].search;
						console.log(fukugou_APIres[i]);

						let sparqlres = await create_linked_string_ambi(name, info, fukugou_APIres[i].word_position, checklist, matchlist, searched_category, wikidata_log, SPARQL_log);
						sparqlres.pos_detail_1 = fukugou_APIres[i].pos.pos_detail_1;
						sparqlres.pos_detail_2 = fukugou_APIres[i].pos.pos_detail_2;
						sparqlres.pos_detail_3 = fukugou_APIres[i].pos.pos_detail_3;
						sparqlres.word_count = fukugou_APIres[i].word_count;
						fukugou_linked_string.push(sparqlres);

					}

				} else {
					for (let i = 0; i < fukugou_APIres.length; i++) {
						//console.log(fukugou_APIres[i]);
						let wikidata_ids = '';
						let name = fukugou_APIres[i].name;
						let info = fukugou_APIres[i].search;

						//console.log(name, info);
						let sparqlres = await create_linked_string_forward(name, info, fukugou_APIres[i].word_position, checklist, matchlist, searched_category, wikidata_log, SPARQL_log);
						for (let j = 0; j < fukugou_APIres[i].pos.length; j++) {
							if (j == 0) {
								sparqlres.pos_detail_1 = fukugou_APIres[i].pos[j].pos_detail_1;
								sparqlres.pos_detail_2 = fukugou_APIres[i].pos[j].pos_detail_2;
								sparqlres.pos_detail_3 = fukugou_APIres[i].pos[j].pos_detail_3;
							} else {
								sparqlres.pos_detail_1 += '.' + fukugou_APIres[i].pos[j].pos_detail_1;
								sparqlres.pos_detail_2 += '.' + fukugou_APIres[i].pos[j].pos_detail_2;
								sparqlres.pos_detail_3 += '.' + fukugou_APIres[i].pos[j].pos_detail_3;
							}

						}
						sparqlres.word_count = fukugou_APIres[i].word_count;
						fukugou_linked_string.push(sparqlres);

					}
				}
				//console.log(fukugou_linked_string);

			}
			//--------------------------------------------END 複合語検索--------------------------------------------------------------------------------------
			//リンクテキスト
			//used linked_string
			let linked_string = new Array();
			for (let i = 0; i < words.length; i++) {
				let judge = false;
				if (fukugou_linked_string != null) {
					judge = fukugou_linked_string.some((data) => data.word_position == words[i].word_position);
				}
				if (judge) {
					let index = fukugou_linked_string.findIndex(({ word_position }) => word_position == words[i].word_position);
					i += (fukugou_linked_string[index].word_count - 1);

				} else {
					//検索対象のwikidataid
					let wikidata_ids = '';
					if (searchtype == "Full") {
						//前方一致でAPIでwikidataに問い合わせ
						let APIresponse = await promise_get_action_wbsearchentities(words[i].surface_form, APIlimit);
						//console.log("サーチAPI結果(前方一致)", APIresponse);
						let name = APIresponse.searchinfo.search;
						let info = new Array();
						// for (let j = 0; j < APIresponse.search.length; j++) {
						// 	if (APIresponse.search[j].match.text == words[i].surface_form) {
						// 		info.push(APIresponse.search[j]);
						// 	}
						// }
						for (let search of APIresponse.search) {
							if (search.match.text == words[i].surface_form) {
								info.push(search);
							}
						}
						if (info.length != 0) {
							let sparqlres = await create_linked_string_forward(name, info, words[i].word_position, checklist, matchlist, searched_category, wikidata_log, SPARQL_log);
							sparqlres.pos_detail_1 = words[i].pos_detail_1;
							sparqlres.pos_detail_2 = words[i].pos_detail_2;
							sparqlres.pos_detail_3 = words[i].pos_detail_3;
							//used linked_string
							linked_string.push(sparqlres);
						}
					} else if (searchtype == "forward") {
						//前方一致でAPIでwikidataに問い合わせ
						let APIresponse = await promise_get_action_wbsearchentities(words[i].surface_form, APIlimit);
						if (APIresponse.search.length != 0) {
							//console.log("サーチAPI結果(前方一致)", APIresponse);
							let name = APIresponse.searchinfo.search;
							let info = APIresponse.search;

							let sparqlres = await create_linked_string_forward(name, info, words[i].word_position, checklist, matchlist, searched_category, wikidata_log, SPARQL_log);
							//used linked_string
							linked_string.push(sparqlres);
						}
					} else if (searchtype == "ambi") {
						//あいまいでAPIでwikidataに問い合わせ
						let APIresponse = await promise_get_list_search(words[i].surface_form, APIlimit)
						//console.log("サーチAPI結果(あいまい)対象:" + words[i].surface_form, APIresponse.query);
						if (APIresponse.query.search.length != 0) {
							let name = words[i].surface_form;
							let info = APIresponse.query.search;

							let sparlqres = await create_linked_string_ambi(name, info, words[i].word_position, checklist, matchlist, searched_category, wikidata_log, SPARQL_log);
							//used linked_string
							linked_string.push(sparlqres);
						}

					}
				}
			}
			console.log('wikidata検索結果', wikidata_log);
			console.log('SPARQL検索結果', SPARQL_log);

			//重複の削除
			if (fukugou_linked_string != null) {
				const result = fukugou_linked_string.filter((item, index, self) => {
					// name だけをリスト化する
					const idList = self.map(item => item['wikidata_id']);
					// 重複を削除する
					if (idList.indexOf(item.wikidata_id) === index) {
						return item;
					}
				});
				//console.log(result);
				fukugou_linked_string = result;
			}
			//used linked_string
			if (linked_string != null) {
				//used linked_string
				const result = linked_string.filter((item, index, self) => {
					// id だけをリスト化する
					const idList = self.map(item => item['wikidata_id']);
					//console.log(item.wikidata_id);
					// 重複を削除する
					if (idList.indexOf(item.wikidata_id) === index) {
						return item;
					}
				});
				//console.log(result);
				//used linked_string
				linked_string = result;
			}

			//文章の組み立て
			let LOG = new Array();
			for (let i = 0; i < tokens.length; i++) {
				let judge0;
				let judge;
				if (fukugou_linked_string != null) {
					judge0 = fukugou_linked_string.some((data) => data.word_position == tokens[i].word_position);
				}
				//used linked_string
				if (linked_string != null) {
					//used linked_string
					judge = linked_string.some((data) => data.word_position == tokens[i].word_position);
				}
				//console.log(judge0);
				if (judge0 === true) {
					for (let j = 0; j < fukugou_linked_string.length; j++) {
						if (fukugou_linked_string[j].word_position == tokens[i].word_position) {
							if (linktype == 'kgs') {
								textOUTPUT += fukugou_linked_string[j].kgslink;
							} else if (linktype == 'wikidata') {
								textOUTPUT += fukugou_linked_string[j].link;
							}
							LOG.push(fukugou_linked_string[j]);
							//console.log(fukugou_linked_string[j].link);
							i += (fukugou_linked_string[j].word_count - 1);
							break;
						}
					}
				} else if (judge === true) {
					//console.log(tokens[i].surface_form)
					//used linked_string
					for (let j = 0; j < linked_string.length; j++) {
						//used linked_string
						if ((linked_string[j].word_position == tokens[i].word_position) && (linked_string[j].name == tokens[i].surface_form)) {
							if (linktype == 'kgs') {
								//used linked_string
								textOUTPUT += linked_string[j].kgslink;
							} else if (linktype == 'wikidata') {
								//used linked_string
								textOUTPUT += linked_string[j].link;
							}
							//used linked_string
							LOG.push(linked_string[j]);
							break;
						}
					}
				} else if (judge == false) {
					textOUTPUT += tokens[i].surface_form;
				}
			}

			//単語の出現順にソート
			LOG.sort(function (a, b) {
				return a.word_position - b.word_position;
			});
			console.log('置き換えられた単語', LOG);
			CSVLOG = LOG;
			for (let i = 0; i < CSVLOG.length; i++) {
				delete CSVLOG[i].kgslink;
				delete CSVLOG[i].link;
			}

			//検索結果のカテゴリー表示エリア
			const resultArea0 = document.getElementById('result_category');
			resultArea0.innerHTML = '<H2>カテゴリー</H2>' + searched_category;

			//アノテーション後のテキスト表示エリア
			const resultArea1 = document.getElementById('result_div');
			resultArea1.innerHTML = '<H2>アノテーション結果</H2>' + textOUTPUT;
			document.getElementById('download').style.display = 'inline'

			//wikidata埋め込み用表示エリア
			//const resultArea2 = document.getElementById('result_div_wiki');
			//resultArea2.innerHTML = '<iframe id="kg" name="kg" width=450" height="600" ></iframe>';

			// Loading 画像を消す
			removeLoading()

			return resultArea1;
		}
	</script>

	<script>
		/*
		ローカルで行う場合、vscodeで作業を推奨。
		vscodeの拡張機能「Live server」を導入し、右下のGo Liveからデバッグ作業を行うと
		kuromoji.jsを使用する際にローカルファイル読み込みエラーが起こらない。
		拡張機能を用いない場合は、nodeとnpmをインストールし、http-serverをインストールして実行すれば表示できます。
		*/

		const keylink = "item";	//リンクのkeyとする変数
		const detail_html = "details.html"; //詳細表示用のHTMLファイル
		detailsType = "window";//詳細表示の表示先("window":別Window，"iframe":iframeで同一画面，"blank":別タブ)
		isShowQuery = true;//「クエリ表示」ボタンを表示するか？（サービス公開時はfalseにするとよい）
		var CSVLOG;//csv出力用のグローバル変数

		window.addEventListener('load', () => {

			//例文の呼び出し
			example1();

			//console.log("DBペディアカテゴリー", dbpedia_categorylist);
			//console.log("カテゴリー0階層目",CATcheckbox);

			//アノテーション実行ボタン
			const anotateButton = document.getElementById('anotate');
			anotateButton.addEventListener('click', () => {
				// Loading 画像を表示
				dispLoading("処理中...");
				//アノテーション実行
				main();

			}, false);
		}, false);

		//カテゴリーチェック関数()

		//ラベルのマッチタイプのフィルター
		function label_type(res) {
			//console.log(res);
			let array = new Array();
			const matchtype = radio_value('labelmatchType');
			if (matchtype == 'labelpriority') {
				for (let i = 0; i < res.length; i++) {
					if (res[i].match.type == 'label') {
						array.push(res[i]);
					}
				}
				if (array.lenght > 0) {
					res = array;
					return res;
				} else {
					return res;
				}

			} else if (matchtype != 'default') {
				for (let i = 0; i < res.length; i++) {
					if (res[i].match.type == matchtype) {
						array.push(res[i]);
					}
				}
				res = array;
				return res;
			} else {
				return res;
			}
		}

		//カテゴリー選択関数
		function select_category(id, query_data, checklist, matchlist,) {
			let purpose_id = new Array();
			let color = new Array();
			//console.log(query_data);
			for (let i of id) {
				//console.log("id", i);
				for (let q of query_data) {
					//console.log(q);
					let idx1 = Array.from(matchlist.values()).indexOf(q.o.value);
					if ((idx1 != -1) && (q.s.value.indexOf(i) != -1)) {

						//console.log('選択されたカテゴリー',Array.from(matchlist.values()));
						//console.log('カテゴリーにマッチしたID', q);
						//console.log(idx1);

						purpose_id.push(q);
						let idx2 = Array.from(checklist.values()).indexOf(Array.from(matchlist.entries())[idx1][0]);
						reg = new RegExp("cat-\d(-\d)+", "g");

						if (idx2 != -1) {
							//console.log(Array.from(checklist.values()));
							//console.log(Array.from(matchlist.entries())[idx1][0]);
							//console.log(idx2);

							let tmp;
							if (reg.test(Array.from(checklist.entries())[idx2][0])) {
								let tmp1 = Array.from(checklist.entries())[idx2][0].slice(5);
								tmp = Array.from(checklist.entries())[idx2][0].replace(tmp1, "");
							} else {
								tmp = Array.from(checklist.entries())[idx2][0];
							}
							let idx3 = Object.keys(category_color).indexOf(tmp);
							color.push(category_color['cat-' + idx3]);

							//console.log(Array.from(checklist.entries())[idx2][0]);
							//console.log(idx3);
							//console.log(category_color);
							//console.log(category_color['cat-' + idx3]);
						}

					}
				}
			}
			//console.log(purpose_id);
			//console.log(color);
			let res = [purpose_id[0], color[0]];

			return res;
		}

		//検索結果カテゴリー作成用関数(サーチ後のカテゴリ一覧,sparqlqerydata)
		function create_category(category, data) {
			//下のコードでサーチ後のカテゴリー作成
			let OLABEL = new Array();
			for (let j = 0; j < data.length; j++) {
				OLABEL.push(data[j].oLabel.value);
				if (category.indexOf(data[j].oLabel.value) == -1) {
					category.push(data[j].oLabel.value);
				}
			}
			return OLABEL;
		}

		//ブラックリストの照会をして、削除したものを返す(ブラックリスト,形態素解析結果（名詞）)
		function match_blacklist(blacklist, target) {
			let list = new Array();
			for (let i = 0; i < target.length; i++) {
				let existPos1 = blacklist.some((word) => word == target[i].pos_detail_1);
				let existPos2 = blacklist.some((word) => word == target[i].pos_detail_2);
				let existPos3 = blacklist.some((word) => word == target[i].pos_detail_3);

				if ((existPos1 || existPos2 || existPos3) == false) {
					list.push(target[i]);
				}
			}
			return list;
		}

		//ホワイトリストの照会をして、削除したものを返す(ホワイトリスト,形態素解析結果（名詞）)
		function match_whitelist(whitelist, target) {
			let list = new Array();
			for (let i = 0; i < whitelist.length; i++) {
				for (let j = 0; j < target.length; j++) {
					if (whitelist[i] === target[j].pos_detail_1) {
						list.push(target[j]);
					} else if (whitelist[i] === target[j].pos_detail_2) {
						list.push(target[j]);
					} else if (whitelist[i] === target[j].pos_detail_3) {
						list.push(target[j]);
					}
				}
			}
			return list;
		}

		//NG検索ワードの排除
		function NGword(target) {
			let list = new Array();
			const ngword = document.getElementById('NGtext').value.split(',');
			for (let i = 0; i < target.length; i++) {
				let flag = ngword.some((word) => word == target[i].surface_form);
				if (flag == false) {
					list.push(target[i]);
				}
			}
			return list;
		}

		function createWikidataLinkHtmlStr(wikidataUrl, className, value) {

			return '<b>' + ('<a '('href="' + link + '" ') + ('class="' + className + '" ') + ('style="background:' + s_cat[1] + '" ') + 'target="_blank">' + value + '</a>') + '</b>';
		}
		//カテゴリーのマッチメイキング、リンクテキストの生成(検索単語, APIres.search, 単語の位置, checklist, matchlist, 結果格納配列,ログ格納用配列)
		async function create_linked_string_forward(name, info, word_position, checklist, matchlist, searched_category, wikidata_log, SPARQL_log) {

			//ログを蓄積
			wikidata_log.push({ 'name': name, 'info': info });

			//APIの結果を整形し、SPARQLで問い合わせ
			if (info.length !== 0) {
				if (Array.from(checklist.entries()).length != 0) {

					let id = new Array();
					let wikidata_ids = '';
					//sparqlqeryの生成、問い合わせ
					//console.log(info);
					for (let j = 0; j < info.length; j++) {
						id.push(info[j].id);
						wikidata_ids += "wd:" + info[j].id + " ";
					}
					let query_data = await sparql_query(wikidata_ids);
					//console.log("クエリの結果", query_data);
					SPARQL_log.push({ 'name': name, 'SPARQL': query_data });
					//console.log(Array.from(checklist.entries()).length);

					//カテゴリーにマッチしたwikidataidと色の対応
					let s_cat = select_category(id, query_data, checklist, matchlist);
					//console.log(Array.isArray(s_cat[0]));
					if (s_cat[0] !== undefined) {
						//console.log(s_cat[0]);
						wikidata_log.pop();
						wikidata_log.push({ 'name': name, 'info': info, 'category': create_category(searched_category, query_data) });
						const wikidataId = s_cat[0].s.value.replace("http://www.wikidata.org/entity/", "");
						const wikidataUrl = s_cat[0].s.value;
						const kgsLink = 'https://kgs.hozo.jp/sample/details.html?key=wd:' + wikidataId;
						const kgsLinkHtml = '<b><a ' + ('href="' + "javascript:ShowDetails('" + kgsLink + "');" + '"') + (' style="' + 'background:' + s_cat[1] + '"') + '>' + name + '</a></b>';
						const link = 'https://www.wikidata.org/wiki/' + wikidataId;
						const linkHtml = '<b>' + ('<a '('href="' + link + '" ') + ('style="background:' + s_cat[1] + '" ') + 'target="_blank">' + name + '</a>') + '</b>';
						//リンクテキストの生成
						return ({
							'name': name,
							'word_position': word_position,
							'wikidata_id': wikidataId,
							'wikidataURL': wikidataUrl,
							'kgslink': kgsLinkHtml,
							'link': linkHtml
						});
					} else {
						const wikidataId = info[0].title;
						const wikidataUrl = info[0].concepturi;
						const kgsLink = 'https://kgs.hozo.jp/sample/details.html?key=wd:' + wikidataId;
						const kgsLinkHtml = '<b><a ' + ('href="' + "javascript:ShowDetails('" + kgsLink + "');" + '"') + '>' + name + '</a></b>';
						const link = 'https://www.wikidata.org/wiki/' + wikidataId;
						const linkHtml = '<b>' + ('<a '('href="' + link + '" ') + 'target="_blank">' + name + '</a>') + '</b>';
						return ({
							'name': name,
							'word_position': word_position,
							'wikidata_id': wikidataId,
							'wikidataURL': wikidataUrl,
							'kgslink': kgsLinkHtml,
							'link': linkHtml
						});
					}
				} else {
					const wikidataId = info[0].title;
					const wikidataUrl = info[0].concepturi;
					const kgsLink = 'https://kgs.hozo.jp/sample/details.html?key=wd:' + wikidataId;
					const kgsLinkHtml = '<b><a ' + ('href="' + "javascript:ShowDetails('" + kgsLink + "');" + '"') + '>' + name + '</a></b>';
					const link = 'https://www.wikidata.org/wiki/' + wikidataId;
					const linkHtml = '<b>' + ('<a ' + ('href="' + link + '" ') + 'target="_blank">' + name + '</a>') + '</b>';
					console.log("タイトル" + info[0].title);
					console.log("id" + info[0].id);
					return ({
						'name': name,
						'word_position': word_position,
						'wikidata_id': info[0].title,
						'wikidataURL': info[0].concepturi,
						'kgslink': '<b><a href="javascript:ShowDetails(' + "'https://kgs.hozo.jp/sample/details.html?key=wd:" + info[0].id + "');" + '">' + name + '</a></b>',
						'link': '<b><a href="https://www.wikidata.org/wiki/' + info[0].id + '" target="_blank">' + name + '</a></b>'
					});
				}

			}
		}

		async function create_linked_string_ambi(name, info, word_position, checklist, matchlist, searched_category, wikidata_log, SPARQL_log) {

			//ログを蓄積
			wikidata_log.push({ 'name': name, 'info': info });

			//APIの結果を整形し、SPARQLで問い合わせ
			if (info.length !== 0) {
				if (Array.from(checklist.entries()).length != 0) {
					let id = new Array();
					let wikidata_ids = '';
					//sparqlqeryの生成、問い合わせ
					for (let j = 0; j < info.length; j++) {
						id.push(info[j].title);
						wikidata_ids += "wd:" + info[j].title + " ";
					}
					query_data = await sparql_query(wikidata_ids);
					//console.log("クエリの結果", query_data);
					SPARQL_log.push({ 'name': name, 'SPARQL': query_data });
					//カテゴリーにマッチしたwikidataidと色の対応
					let s_cat = select_category(id, query_data, checklist, matchlist);
					//console.log(Array.isArray(s_cat[0]));
					if (s_cat[0] !== undefined) {
						wikidata_log.pop();
						wikidata_log.push({ 'name': name, 'info': info, 'category': create_category(searched_category, query_data) });
						//リンクテキストの生成
						return ({
							'name': name, 'word_position': word_position, 'wikidata_id': s_cat[0].s.value.replace("http://www.wikidata.org/entity/", ""), 'wikidataURL': s_cat[0].s.value
							, 'kgslink': '<b><a href="javascript:ShowDetails('
								+ "'https://kgs.hozo.jp/sample/details.html?key=wd:" + s_cat[0].s.value.replace("http://www.wikidata.org/entity/", "") + "'" + ');"'
								+ 'style ="background:' + s_cat[1] + '">' + name + '</a></b>'
							, 'link': '<b><a href="https://www.wikidata.org/wiki/' + s_cat[0].s.value.replace("http://www.wikidata.org/entity/", "")
								+ '" style ="background:' + s_cat[1] + '" target=_"blank">' + name + '</a></b>'
						});
					} else {
						return ({
							'name': name, 'word_position': word_position, 'wikidata_id': info[0].title, 'wikidataURL': 'http://www.wikidata.org/entity/' + info[0].title
							, 'kgslink': '<b><a href="javascript:ShowDetails(' + "'https://kgs.hozo.jp/sample/details.html?key=wd:"
								+ info[0].title + "');" + '">' + name + '</a></b>'
							, 'link': '<b><a href="https://www.wikidata.org/wiki/' + info[0].title + '" target="_blank">' + name + '</a></b>'
						});
					}
				} else {
					return ({
						'name': name, 'word_position': word_position, 'wikidata_id': info[0].title, 'wikidataURL': 'http://www.wikidata.org/entity/' + info[0].title
						, 'kgslink': '<b><a href="javascript:ShowDetails(' + "'https://kgs.hozo.jp/sample/details.html?key=wd:"
							+ info[0].title + "');" + '">' + name + '</a></b>'
						, 'link': '<b><a href="https://www.wikidata.org/wiki/' + info[0].title + '" target="_blank">' + name + '</a></b>'
					});
				}
			}
		}

		//詳細設定のラジオボタン値取得(ラジオボタン名)
		function radio_value(name) {
			let elements = document.getElementsByName(name);
			let len = elements.length;
			let checkValue = '';

			for (let i = 0; i < len; i++) {
				if (elements.item(i).checked) {
					checkValue = elements.item(i).value;
					return checkValue;
				}
			}
		}

		//整形し、結果画面の文章を出力(形態素解析結果,リンクテキスト)
		function resultOUTPUT(tokens, linkedStr) {
			let j = 0;
			let output = '';
			for (let i = 0; i < tokens.length; i++) {
				if (tokens[i].surface_form == linkedStr[j][0]) {
					output += linkedStr[j][1];
					if (j < linkedStr.length) {
						j++;
					}
					continue;
				} else if (tokens.surface_form != linkedStr[j][0]) {
					output += tokens[i].surface_form;
				}
			}
			return output;
		}

		//別ウィンドウwikidata表示関数
		function ShowDetails(page) {
			let lw = window.innerWidth - 400;
			let y = window.screenY + 100;

			if (lw < 0) { lw = 100; }
			window.open(page, "DetailsWin", "left=" + lw + ",top=" + y + ",width=400,height=600,scrollbars=1");
		}

		//csv関数
		function csvdownload(result) {
			let str = '';
			for (let i = 0; i < result.length; i++) {
				if (i == 0) {
					str += Object.keys(result[i]) + '\r\n';
				}
				str += Object.values(result[i]) + '\r\n';
			}

			const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
			const blob = new Blob([bom, str], { type: "text/csv" }); //配列に上記の文字列(str)を設定
			let link = document.createElement('a');
			link.href = URL.createObjectURL(blob);
			link.download = result[0].name + '_' + times() + ".csv";
			link.click();
		}

		//csvダウンロードファイル名の時間呼び出し
		function times() {
			const now = new Date();

			const Year = now.getFullYear();
			const Month = now.getMonth() + 1;
			const date = now.getDate();
			const Hour = now.getHours();
			const Min = now.getMinutes();
			const Sec = now.getSeconds();

			return (Month + "月" + date + "日" + Hour + "時" + Min + "分" + Sec + "秒");
		}
	</script>
</head>

<body>
	<h1>Wikidataのクラス階層を用いたエンティティリンキング</h1>
	<hr>
	<main>
		<h3>
			<a class="treeview" href="https://github.com/masapi61/Annotation-by-Wikidata" target="_blank">
				使い方(githubレポジトリ)
			</a>
		</h3>
		<div class="left-column0">
			<ul class="treeview">
				<b>カテゴリー</b>:<br>
				<li class="expandable"><input class="hierarchy0" type="checkbox" id="cat-0" value="activity">
					<label for="cat-0" style="background:rgb(255, 143, 143)" #>活動</label>
					<ul>
						<li class="expandable"><input class="hierarchy1" type="checkbox" id="cat-0-0" value="game">
							<label for="cat-0-0" style="background:rgb(255, 143, 143)">ゲーム</label>
						</li>
						<li class="expandable"><input class="hierarchy1" type="checkbox" id="cat-0-1" value="sport">
							<label for="cat-0-1" style="background:rgb(255, 143, 143)">スポーツ</label>
						</li>
					</ul>
				</li>
				<li class="expandable"><input class="hierarchy0" type="checkbox" id="cat-1"
						value="class of anatomical entity"> <label for="cat-1"
						style="background:gainsboro">解剖学的構造</label>
				</li>
				<li class="expandable"><input class="hierarchy0" type="checkbox" id="cat-2" value="disease">
					<label for="cat-2" style="background:rgb(117, 214, 161)">疾患</label>
				</li>
				<li class="expandable"><input class="hierarchy0" type="checkbox" id="cat-3" value="drug"> <label
						for="cat-3" style="background:yellow">薬</label></li>
				<li class="expandable"><input class="hierarchy0" type="checkbox" id="cat-4" value="organisation">
					<label for="cat-4" style="background:rgb(204, 179, 255)">組織</label>
				</li>
				<li class="expandable"><input class="hierarchy0" type="checkbox" id="cat-5" value="person">
					<label for="cat-5" style="background:orange">人物</label>
				</li>
				<li class="expandable"><input class="hierarchy0" type="checkbox" id="cat-6" value="place">
					<label for="cat-6" style="background:peachpuff">場所</label>
				</li>
				<li class="expandable"><input class="hierarchy0" type="checkbox" id="cat-7" value="chemical substance">
					<label for="cat-7" style="background:aqua">化学物質</label>
				</li>
				<li class="expandable"><input class="hierarchy0" type="checkbox" id="cat-8"
						value="group or class of organisms">
					<label for="cat-8" style="background:lime">生物</label>
				</li>
				<li class="expandable"><input class="hierarchy0" type="checkbox" id="cat-9" value="work">
					<label for="cat-9" style="background:pink">仕事</label>
				</li>
			</ul>
		</div>

		<div class="left-column">
			<button id="example1" onclick="example1()">例文1</button>
			<button id="example2" onclick="example2()">例文2</button>
			<button id="example3" onclick="example3()">例文3</button>
			<details>
				<summary><b>詳細設定</b></summary>
				<div class="left-column">
					<p>
						<b>ラベルの検索設定</b>:<br>
						<label><input type="radio" id="LabelFull" name="labelType" value="Full" checked>完全一致</label><br>
						<label><input type="radio" id="LabelForward" name="labelType" value="forward">前方一致</label><br>
						<label><input type="radio" id="LabelAmbi" name="labelType" value="ambi">あいまい検索</label><br>
						<label>ラベル取得上限数 <input type="text" id="APIlimit" value="10" size="3"></label><br><br>

						<b>ラベルのマッチ項目設定(完全一致検索、前方一致検索のみ)</b>:<br>
						<label><input type="radio" id="TypeLavelpriority" name="labelmatchType" value="labelpriority"
								checked>ラベル名優先</label><br>
						<label><input type="radio" id="TypeLavel" name="labelmatchType" value="label">ラベル名のみ</label><br>
						<label><input type="radio" id="TypeAlias" name="labelmatchType" value="alias">別名のみ</label><br>
						<label><input type="radio" id="TypeDefault" name="labelmatchType"
								value="default">どちらも</label><br><br>

						<b>品詞の選択</b>:<br>
						<label>
							<input type="radio" name="radio_noun" value="u_noun">固有名詞のみ
						</label><br>
						<label>
							<input type="radio" name="radio_noun" value="noun">名詞のみ
						</label><br>
						<label>
							<input type="radio" name="radio_noun" value="noun_w">名詞ホワイトリスト
						</label><br>
						<input type="text" id="noun_w" size="40" value="固有名詞,一般,サ変接続"><br>
						<label>
							<input type="radio" name="radio_noun" value="noun_b" checked>名詞ブラックリスト</label><br>
						<input type="text" id="noun_b" size="40" value="接続詞的,代名詞,非自立,特殊,形容動詞語幹"><br><br>

						<b>NGワード</b><br>
						<input type="text" id="NGtext" size="40" value="[,],][,]、,:,(,),注,.,_,英,&quot;"><br><br>

						<b>リンク先表示方法</b><br>
						<label><input type="radio" id="kgs" name="linkType" value="kgs"
								checked>KGSearchForWD</label><br>
						<label><input type="radio" id="wikidata" name="linkType" value="wikidata">wikidata</label><br>
					</p>
				</div>

			</details>
			<textarea id="input_text"></textarea>
			<br>
			<button id="anotate">アノテーション実行</button><br>
			<div id="download" style="display:none">
				<input type="button" id="downloadbtn" value="ダウンロード" style="margin-top:8px;"
					onclick="csvdownload(CSVLOG)"><br>
			</div>
			<div style="display:none">
				<div id="result_category"></div>
			</div>
			<div id="result_div"></div>
		</div>

		<div class="left-column">
			<div id="result_div_wiki"></div>
		</div>
	</main>

</body>

</html>